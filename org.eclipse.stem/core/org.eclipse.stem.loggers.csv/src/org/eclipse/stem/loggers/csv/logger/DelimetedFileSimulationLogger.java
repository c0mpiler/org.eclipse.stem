/*******************************************************************************
 * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
 * IBM Corporation, BfR, and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation and new features
 *     Bundesinstitut f√ºr Risikobewertung - Pajek Graph interface, new Veterinary Models
 *******************************************************************************/
package org.eclipse.stem.loggers.csv.logger;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.impl.AdapterImpl;
import org.eclipse.stem.core.graph.Graph;
import org.eclipse.stem.core.graph.GraphPackage;
import org.eclipse.stem.core.model.Decorator;
import org.eclipse.stem.core.model.IntegrationDecorator;
import org.eclipse.stem.core.scenario.Scenario;
import org.eclipse.stem.jobs.simulation.ISimulation;
import org.eclipse.stem.jobs.simulation.SimulationEvent;
import org.eclipse.stem.jobs.simulation.SimulationState;
import org.eclipse.stem.loggers.csv.Activator;
import org.eclipse.stem.loggers.csv.CSVLogger;
import org.eclipse.stem.loggers.csv.logger.html.HtmlScenarioPage;

/**
 * Simulation logger for creating entry-delimeted text files
 * for the output of the simulation.  THe class accepts an 
 * underlying logger (CSVLogger) that specifies the parameters
 * such as the type of delimeter (comma-separated values, for example)
 *
 */
public class DelimetedFileSimulationLogger 
{
	/**
	 * Underlying logger model to use for configuration
	 */
	private CSVLogger logger;
	
	/**
	 * Simulation to log
	 */
	private ISimulation simulation;
	
	/**
	 * Path to the log file directory
	 */
	private File logDirectory;
	
	/**
	 * 
	 */
	private final List<String> excludedDecorators = new ArrayList<String>(Arrays.asList(Constants.EXCLUDED_DECORATOR_DEFAULTS));
	
	/**
	 * 
	 */
	private final List<DelimetedFileDecoratorLogger> decoratorLoggers = new ArrayList<DelimetedFileDecoratorLogger>();
	
	
	
	/**
	 * @param logger
	 * @param simulation
	 */
	public DelimetedFileSimulationLogger(CSVLogger logger, ISimulation simulation)
	{
		this.logger = logger;
		this.simulation = simulation;
		
		createLoggersForDecorators();
		if (logger.isLogHtmlSummary()) {
			generateHtmlSummary(simulation.getScenario());
		}
	}
	

	
	
	
	/**
	 * @return The underlying model for this simulation logger
	 */
	public CSVLogger getLogger()
	{
		return logger;
	}
	
	/**
	 * @return The logger's simulation
	 */
	public ISimulation getSimulation()
	{
		return simulation;
	}
	
	
	/**
	 * Gets the base log directory for all log files generated by this simulation
	 * @return
	 */
	public File getLogDirectory()
	{
		if (logDirectory == null) {
			
			StringBuilder directory = new StringBuilder();
			
			if (logger.isUseDefaultLogDirectory() || Constants.EMPTY_STRING.equals(logger.getDataPath())) {
				directory.append(FileUtils.getRootLoggingFolderForScenario(simulation.getScenario().getURI().toString()));
			} else {
				directory.append(logger.getDataPath());
			}
			
			directory.append(Constants.SYSTEM_PATH_SEPARATOR);
			directory.append(simulation.getUniqueIDString());
			directory.append(Constants.SYSTEM_PATH_SEPARATOR);
			
			logDirectory = new File(directory.toString());
		}
		return logDirectory;
	}
	
	
	private void generateHtmlSummary(Scenario s)
	{
		try {
			new HtmlScenarioPage(s, getLogDirectory()).generate();
		} catch (IOException ioe) {
			Activator.logInformation(Messages.DFSL_WriteScenarioSummaryError, ioe);
		}
	}
	
	/**
	 * Starts the loggers created by initializing and starting all decorator loggers
	 */
	public void start()
	{
		for (DelimetedFileDecoratorLogger logger : decoratorLoggers) {
			logger.start();

			if (logger.getLogger().isLogRunParameters()) {
				logger.writeRunParameters();
			}
			
			if (logger.getLogger().isLogInitialState()) {
				logger.log();
			}
		}
	}
	
	/**
	 * Stops the simulation logger by stopping and closing all decorator loggers
	 */
	public void stop()
	{
		for (DelimetedFileDecoratorLogger logger : decoratorLoggers) {
			logger.stop();
		}
	}
	
	/**
	 * Performs logging for a given simulation for the last generated event
	 * @param event
	 */
	public void log(SimulationEvent event)
	{
		
//		// if this is an Evolving Disease model we need to clone any new children
//	    if((EvolvingDiseaseModel.newChildrenToLog != null)&&(EvolvingDiseaseModel.newChildrenToLog.size() > 0)){
//	    	
//	    	EvolvingDiseaseModel evolvingDecorator = null;
//	    	DelimetedFileDecoratorLogger parentLogger = null;
//			for (DelimetedFileDecoratorLogger logger : decoratorLoggers) {
//				IntegrationDecorator decorator = logger.decorator;
//				if(decorator instanceof EvolvingDiseaseModel) {
//					parentLogger = logger;
//					evolvingDecorator = (EvolvingDiseaseModel)decorator;
//					break;
//				}
//			}
//			
//			synchronized(this) {
//				// New loggers for new clones from EvolvingDiseaseModel.newChildrenToLog
//				if(EvolvingDiseaseModel.newChildrenToLog.size() > 0) {
//					for(EvolvingDiseaseModel decorator:EvolvingDiseaseModel.newChildrenToLog) {
//						this.addChildDecoratorLogger(parentLogger, (IntegrationDecorator)decorator);
//					}
//					EvolvingDiseaseModel.newChildrenToLog.clear();
//				}
//			}
//	    }// if EVOLVING then prepare to log children
		
		
		for (DelimetedFileDecoratorLogger logger : decoratorLoggers) {
			if (event.getSimulationState().equals(SimulationState.PAUSED)) {
				logger.flush();
			} else if (event.getSimulationState().equals(SimulationState.COMPLETED_CYCLE)) {
				logger.log();
			}
		}
	}
	
	/**
	 * Creates the loggers for all valid decorators in the scenario
	 */
	private void createLoggersForDecorators() 
	{
		List<IntegrationDecorator> decorators = getDecoratorsToLog();
		
		for (IntegrationDecorator decorator : decorators) {
			decoratorLoggers.add(new DelimetedFileDecoratorLogger(this, decorator));
		}
	}
	
	/**
	 * SPLUNGE 1
	 * This method is called only for evolving disease models when a new logger is created for a new child disease
	 * @param decorator
	 */
	protected void addChildDecoratorLogger(IntegrationDecorator decorator) {
//		for (DelimetedFileDecoratorLogger logger : decoratorLoggers) {
//			if (logger.decorator == parent) {
//				
//			}
//		}
		// TODO JHK: the true flag prevents child loggers from logging summaries (which causes a recursion error and should not be logged anyway).
		DelimetedFileDecoratorLogger childLogger = new DelimetedFileDecoratorLogger(this, decorator, true);
		decoratorLoggers.add(childLogger);
//		childLogger.start();
	}
	

	/**
	 * Checks if the specified decorator is explicitly excluded by class name
	 * @param d
	 * @return
	 */
	private boolean isExcludedDecorator(Decorator d)
	{
		return excludedDecorators.contains(d.eClass().getInstanceClass().getName());
	}
	

	/**
	 * Gets the decorators from the scenario that are valid for logging
	 * @return
	 */
	private List<IntegrationDecorator> getDecoratorsToLog()
	{
		List<IntegrationDecorator> decorators = new ArrayList<IntegrationDecorator>();
		
		simulation.getScenario().getCanonicalGraph().eAdapters().add(new AdapterImpl() {

			@Override
			public void notifyChanged(Notification msg) {
				
				super.notifyChanged(msg);
				int featureId = msg.getFeatureID(Graph.class);
				
				if (featureId == GraphPackage.GRAPH__DECORATORS) {
					if (msg.getNewValue() instanceof IntegrationDecorator) {
						addChildDecoratorLogger((IntegrationDecorator)msg.getNewValue());
						//System.out.println(msg);
					}
					
					
				}
				
				//addChildDecoratorLogger(parentLogger, (IntegrationDecorator)decorator);
			}

			
			
		});
		
		
		for (Decorator decorator : simulation.getScenario().getCanonicalGraph().getDecorators()) {
			if(decorator instanceof IntegrationDecorator 
					&& !isExcludedDecorator(decorator)
					&& logger.getDecoratorProperties(decorator.getURI()) != null) {
				decorators.add((IntegrationDecorator)decorator);
			}
		}
		
		return decorators;
	}
}
